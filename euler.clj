(require '[clojure.math.numeric-tower :as math])
(require '[clojure.string :as string])

(defn fib-seq
  "Lazy generation of fibonacci sequence, with first and second item"
  [a b]
  (lazy-seq (cons a (fib-seq b (+ a b))) ))

(defn fib-seq'
  "Lazy generation of fibonacci sequence, with first and second item"
  [a b]
  (lazy-seq (cons a (fib-seq' b (+' a b)) )))

(defn lazy-primes
  ([] (lazy-primes (iterate inc 2) []))
  ([xs primes]
   (lazy-seq
     (let [curr-num (first xs)
           primes (conj primes curr-num)
           d-pred (fn [x] (some true? (map #(= 0 (mod x %)) primes)))]
       (cons curr-num (lazy-primes (drop-while d-pred xs) primes))))))

(defn prime?
  "Check if the long-int is a prime number"
  [x]
  (let [till (math/sqrt x)]
    (loop [i 2]
      (if (> i till)
        true
        (if (zero? (rem x i))
          false
          (recur (inc i)))))))

(defn largest-prime-factor
  "Return the largest prime factor for a long-int number"
  ([x y]
   (max (largest-prime-factor x) (largest-prime-factor y)))
  ([x]
   (loop [s (long (math/sqrt x)), r (rem x s), q (quot x s)]
     (if (< s 2)
       x ; x is prime number
       (if (zero? r)
         (largest-prime-factor s q)
         (recur (dec s) (rem x (dec s)) (quot x (dec s))))))))

(defn factorial
  "Factorial of a Long type number"
  [n]
  (reduce #(* %1 %2) 1 (range 1 (inc n))))

(defn factorial'
  "Factorial of arbitrary sized number"
  [n]
  (reduce #(*' %1 %2) 1 (range 1 (inc n))))

(defn palindrom-num?
  "A palindromic number reads the same both ways"
  [x]
  (let [s (str x)] (= s (string/reverse s))))

(defn combination?
  "If the order doesn't matter, it is a Combination. And repeatition is
  not allowed
    formula = n! / (r! * (n-r)!)
  "
  ([coll r acc]
   (letfn [(mklist [x] (map list (iterate #(do %) x)))]
     (cond
       (= r 1) (map conj acc (iterate #(do %) (first coll)))
       :else combination? coll (dec r) (map conj acc (mklist (first coll)))))
  ([coll r]
   (letfn [(mklist [x] (map list (iterate #(do %) x)))]
     (cond
       (<= r 0) nil
       (= r 1) coll
       :else (combination? coll (dec r) (mklist (first coll)))))))

(defn one
  "If we list all the natural numbers below 10 that are multiples
  of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
  Find the sum of all the multiples of 3 or 5 below 1000."
  []
  (let [mul3? #(zero? (rem % 3))
        mul5? #(zero? (rem % 5))]
    (apply + (filter #(or (mul3? %) (mul5? %)) (range 1 1000)))))

(defn two
  "Each new term in the Fibonacci sequence is generated by adding
  the previous two terms. By starting with 1 and 2, the first 10
  terms will be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

  By considering the terms in the Fibonacci sequence whose values do
  not exceed four million, find the sum of the even-valued terms."
  []
  (reduce + (filter even? (take-while #(< % 4000000) (fib-seq 0 1)))))

(defn three
  "The prime factors of 13195 are 5, 7, 13 and 29.
  What is the largest prime factor of the number 600851475143 ?"
  []
  (largest-prime-factor 600851475143))

(defn four
  "A palindromic number reads the same both ways. The largest palindrome
  made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
  Find the largest palindrome made from the product of two 3-digit
  numbers."
  []
  (palindrom-num? 10))
